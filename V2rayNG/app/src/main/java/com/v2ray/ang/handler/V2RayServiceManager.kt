package com.v2ray.ang.handlerimport android.app.Serviceimport android.content.BroadcastReceiverimport android.content.Contextimport android.content.Intentimport android.content.IntentFilterimport android.net.ConnectivityManagerimport android.net.NetworkCapabilitiesimport android.os.Buildimport android.util.Logimport androidx.core.content.ContextCompatimport com.v2ray.ang.AppConfigimport com.v2ray.ang.Rimport com.v2ray.ang.dto.EConfigTypeimport com.v2ray.ang.dto.ProfileItemimport com.v2ray.ang.extension.toastimport com.v2ray.ang.service.ServiceControlimport com.v2ray.ang.service.V2RayProxyOnlyServiceimport com.v2ray.ang.service.V2RayVpnServiceimport com.v2ray.ang.util.MessageUtilimport com.v2ray.ang.handler.PluginServiceManagerimport com.v2ray.ang.util.Utilsimport go.Seqimport kotlinx.coroutines.CoroutineScopeimport kotlinx.coroutines.Dispatchersimport kotlinx.coroutines.Jobimport kotlinx.coroutines.delayimport kotlinx.coroutines.isActiveimport kotlinx.coroutines.launchimport kotlinx.coroutines.withContextimport libv2ray.CoreCallbackHandlerimport libv2ray.CoreControllerimport libv2ray.Libv2rayimport org.json.JSONObjectimport java.lang.ref.SoftReferenceimport java.net.HttpURLConnectionimport java.net.InetSocketAddressimport java.net.Proxyimport java.net.URLobject V2RayServiceManager {    private val coreController: CoreController = Libv2ray.newCoreController(CoreCallback())    private val mMsgReceive = ReceiveMessageHandler()    private var currentConfig: ProfileItem? = null    private var watchdogJob: Job? = null    private var isSwitching = false                  private var lastNetworkType: String? = null      private const val WATCHDOG_INTERVAL = 10_000L           private const val WATCHDOG_STARTUP_DELAY = 20_000L      private const val WATCHDOG_RECHECK_DELAY = 3_000L       private const val SUB_DOMAIN = "sub.xiexievpn.com"    private const val PENALTY_DURATION = 300_000L           private var penalizedConfigType: EConfigType? = null    private var penaltyUntil: Long = 0    fun getPenalizedConfigType(): EConfigType? {        return if (penalizedConfigType != null && System.currentTimeMillis() < penaltyUntil) {            penalizedConfigType        } else {            null        }    }    fun setSwitchingState(switching: Boolean) {        isSwitching = switching        Log.d(AppConfig.TAG, "Watchdog: Switching state set to $switching")    }    var serviceControl: SoftReference<ServiceControl>? = null        set(value) {            field = value            Seq.setContext(value?.get()?.getService()?.applicationContext)            Libv2ray.initCoreEnv(Utils.userAssetPath(value?.get()?.getService()), Utils.getDeviceIdForXUDPBaseKey())        }    fun startVServiceFromToggle(context: Context): Boolean {        if (MmkvManager.getSelectServer().isNullOrEmpty()) {            context.toast(R.string.app_tile_first_use)            return false        }        startContextService(context)        return true    }    fun startVService(context: Context, guid: String? = null) {        if (guid != null) {            MmkvManager.setSelectServer(guid)        }        startContextService(context)    }    fun stopVService(context: Context) {        context.toast(R.string.toast_services_stop)        MessageUtil.sendMsg2Service(context, AppConfig.MSG_STATE_STOP, "")    }    fun isRunning() = coreController.isRunning    fun getRunningServerName() = currentConfig?.remarks.orEmpty()    private fun startContextService(context: Context) {        if (coreController.isRunning) {            return        }        val guid = MmkvManager.getSelectServer() ?: return        val config = MmkvManager.decodeServerConfig(guid) ?: return        if (config.configType != EConfigType.CUSTOM            && !Utils.isValidUrl(config.server)            && !Utils.isPureIpAddress(config.server.orEmpty())        ) return        if (MmkvManager.decodeSettingsBool(AppConfig.PREF_PROXY_SHARING) == true) {            context.toast(R.string.toast_warning_pref_proxysharing_short)        } else {            context.toast(R.string.toast_services_start)        }        val intent = if ((MmkvManager.decodeSettingsString(AppConfig.PREF_MODE) ?: AppConfig.VPN) == AppConfig.VPN) {            Intent(context.applicationContext, V2RayVpnService::class.java)        } else {            Intent(context.applicationContext, V2RayProxyOnlyService::class.java)        }        if (Build.VERSION.SDK_INT > Build.VERSION_CODES.N_MR1) {            context.startForegroundService(intent)        } else {            context.startService(intent)        }    }    fun startCoreLoop(): Boolean {        if (coreController.isRunning) {            return false        }        val service = getService() ?: return false        val guid = MmkvManager.getSelectServer() ?: return false        val config = MmkvManager.decodeServerConfig(guid) ?: return false        val result = V2rayConfigManager.getV2rayConfig(service, guid)        if (!result.status)            return false        try {            val mFilter = IntentFilter(AppConfig.BROADCAST_ACTION_SERVICE)            mFilter.addAction(Intent.ACTION_SCREEN_ON)            mFilter.addAction(Intent.ACTION_SCREEN_OFF)            mFilter.addAction(Intent.ACTION_USER_PRESENT)            ContextCompat.registerReceiver(service, mMsgReceive, mFilter, Utils.receiverFlags())        } catch (e: Exception) {            Log.e(AppConfig.TAG, "Failed to register broadcast receiver", e)            return false        }        currentConfig = config        try {            coreController.startLoop(result.content)        } catch (e: Exception) {            Log.e(AppConfig.TAG, "Failed to start Core loop", e)            return false        }        if (coreController.isRunning == false) {            MessageUtil.sendMsg2UI(service, AppConfig.MSG_STATE_START_FAILURE, "")            NotificationManager.cancelNotification()            return false        }        try {            MessageUtil.sendMsg2UI(service, AppConfig.MSG_STATE_START_SUCCESS, "")            NotificationManager.showNotification(currentConfig)            NotificationManager.startSpeedNotification(currentConfig)            PluginServiceManager.runPlugin(service, config, result.socksPort)        } catch (e: Exception) {            Log.e(AppConfig.TAG, "Failed to startup service", e)            return false        }        return true    }    fun stopCoreLoop(): Boolean {        val service = getService() ?: return false        if (coreController.isRunning) {            CoroutineScope(Dispatchers.IO).launch {                try {                    coreController.stopLoop()                } catch (e: Exception) {                    Log.e(AppConfig.TAG, "Failed to stop V2Ray loop", e)                }            }        }        MessageUtil.sendMsg2UI(service, AppConfig.MSG_STATE_STOP_SUCCESS, "")        NotificationManager.cancelNotification()        try {            service.unregisterReceiver(mMsgReceive)        } catch (e: Exception) {            Log.e(AppConfig.TAG, "Failed to unregister broadcast receiver", e)        }        PluginServiceManager.stopPlugin()        return true    }    fun queryStats(tag: String, link: String): Long {        return coreController.queryStats(tag, link)    }    private fun measureV2rayDelay() {        if (coreController.isRunning == false) {            return        }        CoroutineScope(Dispatchers.IO).launch {            val service = getService() ?: return@launch            var time = -1L            var errorStr = ""            try {                time = coreController.measureDelay(SettingsManager.getDelayTestUrl())            } catch (e: Exception) {                Log.e(AppConfig.TAG, "Failed to measure delay with primary URL", e)                errorStr = e.message?.substringAfter("\":") ?: "empty message"            }            if (time == -1L) {                try {                    time = coreController.measureDelay(SettingsManager.getDelayTestUrl(true))                } catch (e: Exception) {                    Log.e(AppConfig.TAG, "Failed to measure delay with alternative URL", e)                    errorStr = e.message?.substringAfter("\":") ?: "empty message"                }            }            val result = if (time >= 0) {                service.getString(R.string.connection_test_available, time)            } else {                service.getString(R.string.connection_test_error, errorStr)            }            MessageUtil.sendMsg2UI(service, AppConfig.MSG_MEASURE_DELAY_SUCCESS, result)        }    }    private fun getService(): Service? {        return serviceControl?.get()?.getService()    }    private class CoreCallback : CoreCallbackHandler {        override fun startup(): Long {            return 0        }        override fun shutdown(): Long {            val serviceControl = serviceControl?.get() ?: return -1            return try {                serviceControl.stopService()                0            } catch (e: Exception) {                Log.e(AppConfig.TAG, "Failed to stop service in callback", e)                -1            }        }        override fun onEmitStatus(l: Long, s: String?): Long {            return 0        }    }    private class ReceiveMessageHandler : BroadcastReceiver() {        override fun onReceive(ctx: Context?, intent: Intent?) {            val serviceControl = serviceControl?.get() ?: return            when (intent?.getIntExtra("key", 0)) {                AppConfig.MSG_REGISTER_CLIENT -> {                    if (coreController.isRunning) {                        MessageUtil.sendMsg2UI(serviceControl.getService(), AppConfig.MSG_STATE_RUNNING, "")                    } else {                        MessageUtil.sendMsg2UI(serviceControl.getService(), AppConfig.MSG_STATE_NOT_RUNNING, "")                    }                }                AppConfig.MSG_UNREGISTER_CLIENT -> {                }                AppConfig.MSG_STATE_START -> {                }                AppConfig.MSG_STATE_STOP -> {                    Log.i(AppConfig.TAG, "Stop Service")                    serviceControl.stopService()                }                AppConfig.MSG_STATE_RESTART -> {                    Log.i(AppConfig.TAG, "Restart Service")                    serviceControl.stopService()                    Thread.sleep(500L)                    startVService(serviceControl.getService())                }                AppConfig.MSG_MEASURE_DELAY -> {                    measureV2rayDelay()                }            }            when (intent?.action) {                Intent.ACTION_SCREEN_OFF -> {                    Log.i(AppConfig.TAG, "SCREEN_OFF, stop querying stats")                    NotificationManager.stopSpeedNotification(currentConfig)                }                Intent.ACTION_SCREEN_ON -> {                    Log.i(AppConfig.TAG, "SCREEN_ON, start querying stats")                    NotificationManager.startSpeedNotification(currentConfig)                }            }        }    }    fun startConnectionWatchdog() {        stopConnectionWatchdog()        Log.d(AppConfig.TAG, "Watchdog: Starting connection watchdog...")        watchdogJob = CoroutineScope(Dispatchers.IO).launch {            delay(WATCHDOG_STARTUP_DELAY)            Log.d(AppConfig.TAG, "Watchdog: Startup buffer complete, beginning monitoring")            var failCount = 0            lastNetworkType = getCurrentNetworkType()            while (isActive && coreController.isRunning) {                delay(WATCHDOG_INTERVAL)                if (isSwitching) {                    Log.d(AppConfig.TAG, "Watchdog: Skipping check - manual switch in progress")                    continue                }                val currentNetworkType = getCurrentNetworkType()                if (currentNetworkType != lastNetworkType) {                    Log.d(AppConfig.TAG, "Watchdog: Network type changed from $lastNetworkType to $currentNetworkType")                    lastNetworkType = currentNetworkType                    failCount = 0                    delay(5000)                    continue                }                if (!checkProxyConnectivity()) {                    delay(WATCHDOG_RECHECK_DELAY)                    if (!checkProxyConnectivity()) {                        if (checkLocalNetwork()) {                            val serverList = MmkvManager.decodeServerList()                            val currentGuid = MmkvManager.getSelectServer()                            val altGuid = serverList.firstOrNull { it != currentGuid }                            if (serverList.size > 1 && altGuid != null && failCount == 0) {                                Log.d(AppConfig.TAG, "Watchdog: Protocol failover to alternative node")                                if (currentGuid != null) {                                    val failedConfig = MmkvManager.decodeServerConfig(currentGuid)                                    penalizedConfigType = failedConfig?.configType                                    penaltyUntil = System.currentTimeMillis() + PENALTY_DURATION                                    Log.d(AppConfig.TAG, "Watchdog: Penalized protocol ${penalizedConfigType?.name} for 5 min")                                }                                MmkvManager.setSelectServer(altGuid)                                failCount++                                withContext(Dispatchers.Main) {                                    stopCoreLoop()                                    delay(500)                                    startCoreLoop()                                }                                delay(10_000L)                            } else {                                Log.d(AppConfig.TAG, "Watchdog: All protocols failed, fetching new config")                                performSilentRecovery()                                failCount = 0                                delay(15_000L)                            }                        } else {                            Log.d(AppConfig.TAG, "Watchdog: Local network also down, waiting...")                        }                    }                } else {                    failCount = 0                }            }            Log.d(AppConfig.TAG, "Watchdog: Monitoring stopped")        }    }    fun stopConnectionWatchdog() {        watchdogJob?.cancel()        watchdogJob = null        Log.d(AppConfig.TAG, "Watchdog: Stopped")    }    private fun checkProxyConnectivity(): Boolean {        return try {            val proxy = Proxy(Proxy.Type.HTTP, InetSocketAddress("127.0.0.1", 10808))            val url = URL("http:            val connection = url.openConnection(proxy) as HttpURLConnection            connection.connectTimeout = 5000            connection.readTimeout = 5000            connection.instanceFollowRedirects = false            val code = connection.responseCode            connection.disconnect()            code == 204        } catch (e: Exception) {            false        }    }    private fun checkLocalNetwork(): Boolean {        return try {            val url = URL("https:            val connection = url.openConnection() as HttpURLConnection            connection.connectTimeout = 5000            connection.readTimeout = 5000            connection.instanceFollowRedirects = true            val code = connection.responseCode            connection.disconnect()            code == 200        } catch (e: Exception) {            false        }    }    private fun getCurrentNetworkType(): String {        val service = getService() ?: return "unknown"        val connectivityManager = service.getSystemService(Context.CONNECTIVITY_SERVICE) as? ConnectivityManager            ?: return "unknown"        val network = connectivityManager.activeNetwork ?: return "none"        val capabilities = connectivityManager.getNetworkCapabilities(network) ?: return "unknown"        return when {            capabilities.hasTransport(NetworkCapabilities.TRANSPORT_WIFI) -> "wifi"            capabilities.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR) -> "cellular"            capabilities.hasTransport(NetworkCapabilities.TRANSPORT_ETHERNET) -> "ethernet"            else -> "other"        }    }    private suspend fun performSilentRecovery() {        val uuid = MmkvManager.decodeUserUuid()        if (uuid.isNullOrEmpty()) {            Log.w(AppConfig.TAG, "Watchdog: No user UUID found, cannot refresh config")            return        }        val v2rayUrl = refreshConfigFromServer(uuid)        if (v2rayUrl.isNullOrEmpty()) {            Log.w(AppConfig.TAG, "Watchdog: Failed to get new config from server")            return        }        val (count, _) = AngConfigManager.importBatchConfig(v2rayUrl, "", false)        if (count > 0) {            Log.d(AppConfig.TAG, "Watchdog: Config imported, restarting V2Ray core...")            val service = getService()            if (service != null) {                withContext(Dispatchers.Main) {                    stopCoreLoop()                    delay(500)                    startCoreLoop()                    MessageUtil.sendMsg2UI(service, AppConfig.MSG_CONFIG_REFRESHED_SUCCESS, v2rayUrl)                    Log.d(AppConfig.TAG, "Watchdog: Recovery complete, UI notified")                }            }        } else {            Log.w(AppConfig.TAG, "Watchdog: Failed to import new config")        }    }    private fun refreshConfigFromServer(uuid: String): String? {        try {            val url = URL("https:            val conn = url.openConnection() as HttpURLConnection            conn.connectTimeout = 5000            conn.readTimeout = 5000            if (conn.responseCode == 200) {                val text = conn.inputStream.bufferedReader().use { it.readText() }.trim()                if (text.isNotEmpty()) {                    conn.disconnect()                    return text                }            }            conn.disconnect()        } catch (_: Exception) {}        var connection: HttpURLConnection? = null        return try {            val url = URL("https:            connection = url.openConnection() as HttpURLConnection            connection.requestMethod = "POST"            connection.setRequestProperty("Content-Type", "application/json")            connection.doOutput = true            connection.connectTimeout = 10000            connection.readTimeout = 15000            val jsonBody = JSONObject().apply { put("code", uuid) }            connection.outputStream.use { os ->                os.write(jsonBody.toString().toByteArray(Charsets.UTF_8))            }            if (connection.responseCode == HttpURLConnection.HTTP_OK) {                val response = connection.inputStream.bufferedReader().use { it.readText() }                JSONObject(response).optString("v2rayurl", "")            } else {                null            }        } catch (e: Exception) {            Log.e(AppConfig.TAG, "Watchdog: Error refreshing config", e)            null        } finally {            connection?.disconnect()        }    }}
package com.v2ray.ang.uiimport android.Manifestimport android.annotation.SuppressLintimport android.content.Intentimport android.content.pm.PackageManagerimport android.content.res.ColorStateListimport android.net.Uriimport android.net.VpnServiceimport android.os.Buildimport android.os.Bundleimport android.util.Logimport android.view.KeyEventimport android.view.Menuimport android.view.MenuItemimport androidx.activity.OnBackPressedCallbackimport androidx.activity.result.contract.ActivityResultContractsimport androidx.activity.viewModelsimport androidx.appcompat.app.AlertDialogimport androidx.appcompat.widget.SearchViewimport androidx.core.content.ContextCompatimport androidx.core.view.isVisibleimport androidx.lifecycle.lifecycleScopeimport androidx.recyclerview.widget.GridLayoutManagerimport androidx.recyclerview.widget.ItemTouchHelperimport com.google.android.material.tabs.TabLayoutimport com.v2ray.ang.AppConfigimport com.v2ray.ang.AppConfig.VPNimport com.v2ray.ang.Rimport com.v2ray.ang.databinding.ActivityMainBindingimport com.v2ray.ang.dto.EConfigTypeimport com.v2ray.ang.extension.toastimport com.v2ray.ang.extension.toastErrorimport com.v2ray.ang.handler.AngConfigManagerimport com.v2ray.ang.handler.MigrateManagerimport com.v2ray.ang.handler.MmkvManagerimport com.v2ray.ang.handler.PluginServiceManagerimport com.v2ray.ang.handler.UpdateCheckHandlerimport com.v2ray.ang.handler.V2RayNativeManagerimport com.v2ray.ang.helper.SimpleItemTouchHelperCallbackimport com.v2ray.ang.handler.V2RayServiceManagerimport com.v2ray.ang.util.Utilsimport com.v2ray.ang.viewmodel.MainViewModelimport kotlinx.coroutines.Dispatchersimport kotlinx.coroutines.delayimport kotlinx.coroutines.launchimport kotlinx.coroutines.withContextimport org.json.JSONObjectimport java.net.HttpURLConnectionimport java.net.URLclass MainActivity : BaseActivity() {    private val binding by lazy {        ActivityMainBinding.inflate(layoutInflater)    }    private val adapter by lazy { MainRecyclerAdapter(this) }    private val countrySelectorAdapter by lazy { CountrySelectorAdapter() }    private val requestVpnPermission = registerForActivityResult(ActivityResultContracts.StartActivityForResult()) {        if (it.resultCode == RESULT_OK) {            startV2Ray()        }    }    private val requestSubSettingActivity = registerForActivityResult(ActivityResultContracts.StartActivityForResult()) {        initGroupTab()    }    private val tabGroupListener = object : TabLayout.OnTabSelectedListener {        override fun onTabSelected(tab: TabLayout.Tab?) {            val selectId = tab?.tag.toString()            if (selectId != mainViewModel.subscriptionId) {                mainViewModel.subscriptionIdChanged(selectId)            }        }        override fun onTabUnselected(tab: TabLayout.Tab?) {        }        override fun onTabReselected(tab: TabLayout.Tab?) {        }    }    private var mItemTouchHelper: ItemTouchHelper? = null    val mainViewModel: MainViewModel by viewModels()    private var isSwitching = false              private var wasVpnOn = false                 private var currentRegion: String? = null     private var targetRegion: String? = null      private var pollAttempts = 0                 private val maxPollAttempts = 120            private var userUuid: String? = null         private var maxProgress = 0                  companion object {        private const val SUB_DOMAIN = "sub.xiexievpn.com"    }    private val FLAG_TO_REGION = mapOf(        "jp" to "ap-northeast-2",          "us" to "us-west-2",               "jj" to "ap-northeast-1",          "si" to "ap-southeast-1",          "ge" to "eu-central-1",            "sw" to "eu-north-1"           )    override fun onCreate(savedInstanceState: Bundle?) {        super.onCreate(savedInstanceState)        setContentView(binding.root)        binding.fab.setOnClickListener {            if (mainViewModel.isRunning.value == true) {                V2RayServiceManager.stopVService(this)            } else if ((MmkvManager.decodeSettingsString(AppConfig.PREF_MODE) ?: VPN) == VPN) {                val intent = VpnService.prepare(this)                if (intent == null) {                    startV2Ray()                } else {                    requestVpnPermission.launch(intent)                }            } else {                startV2Ray()            }        }        binding.countryRecyclerView.setHasFixedSize(true)        binding.countryRecyclerView.layoutManager = GridLayoutManager(this, 1)        addCustomDividerToRecyclerView(binding.countryRecyclerView, this, R.drawable.custom_divider)        countrySelectorAdapter.initializeCountries(this)        binding.countryRecyclerView.adapter = countrySelectorAdapter        countrySelectorAdapter.setOnCountryClickListener(object : CountrySelectorAdapter.OnCountryClickListener {            override fun onCountryClick(countryCode: String) {                switchRegion(countryCode)            }        })        binding.recyclerView.setHasFixedSize(true)        if (MmkvManager.decodeSettingsBool(AppConfig.PREF_DOUBLE_COLUMN_DISPLAY, false)) {            binding.recyclerView.layoutManager = GridLayoutManager(this, 2)        } else {            binding.recyclerView.layoutManager = GridLayoutManager(this, 1)        }        addCustomDividerToRecyclerView(binding.recyclerView, this, R.drawable.custom_divider)        binding.recyclerView.adapter = adapter        mItemTouchHelper = ItemTouchHelper(SimpleItemTouchHelperCallback(adapter))        mItemTouchHelper?.attachToRecyclerView(binding.recyclerView)        initGroupTab()        setupViewModel()        migrateLegacy()        checkForUpdates()        val userUuid = intent.getStringExtra("user_uuid")        if (!userUuid.isNullOrEmpty()) {            this.userUuid = userUuid              MmkvManager.encodeUserUuid(userUuid)              fetchAndImportConfig(userUuid)        }        onBackPressedDispatcher.addCallback(this, object : OnBackPressedCallback(true) {            override fun handleOnBackPressed() {                isEnabled = false                onBackPressedDispatcher.onBackPressed()                isEnabled = true            }        })    }    @SuppressLint("NotifyDataSetChanged")    private fun setupViewModel() {        mainViewModel.updateListAction.observe(this) { index ->            if (index >= 0) {                adapter.notifyItemChanged(index)            } else {                adapter.notifyDataSetChanged()            }        }        mainViewModel.isRunning.observe(this) { isRunning ->            adapter.isRunning = isRunning            if (isRunning) {                binding.fab.setImageResource(R.drawable.ic_stop_24dp)                binding.fab.backgroundTintList = ColorStateList.valueOf(ContextCompat.getColor(this, R.color.color_fab_active))            } else {                binding.fab.setImageResource(R.drawable.ic_play_24dp)                binding.fab.backgroundTintList = ColorStateList.valueOf(ContextCompat.getColor(this, R.color.color_fab_inactive))            }        }        mainViewModel.configRefreshAction.observe(this) { newV2rayUrl ->            if (!newV2rayUrl.isNullOrEmpty()) {                Log.d("MainActivity", "Watchdog refreshed config, updating UI")                highlightCountryFromUrl(newV2rayUrl)                toast("连接已自动恢复")            }        }        mainViewModel.startListenBroadcast()        mainViewModel.initAssets(assets)    }    private fun migrateLegacy() {        lifecycleScope.launch(Dispatchers.IO) {            val result = MigrateManager.migrateServerConfig2Profile()            launch(Dispatchers.Main) {                if (result) {                    toast(getString(R.string.migration_success))                    mainViewModel.reloadServerList()                } else {                }            }        }    }    private fun initGroupTab() {        binding.tabGroup.removeOnTabSelectedListener(tabGroupListener)        binding.tabGroup.removeAllTabs()        binding.tabGroup.isVisible = false        val (listId, listRemarks) = mainViewModel.getSubscriptions(this)        if (listId == null || listRemarks == null) {            return        }        for (it in listRemarks.indices) {            val tab = binding.tabGroup.newTab()            tab.text = listRemarks[it]            tab.tag = listId[it]            binding.tabGroup.addTab(tab)        }        val selectIndex =            listId.indexOf(mainViewModel.subscriptionId).takeIf { it >= 0 } ?: (listId.count() - 1)        binding.tabGroup.selectTab(binding.tabGroup.getTabAt(selectIndex))        binding.tabGroup.addOnTabSelectedListener(tabGroupListener)        binding.tabGroup.isVisible = true    }    private fun startV2Ray() {        if (MmkvManager.getSelectServer().isNullOrEmpty()) {            toast(R.string.title_file_chooser)            return        }        V2RayServiceManager.startVService(this)    }    public override fun onResume() {        super.onResume()        mainViewModel.reloadServerList()    }    public override fun onPause() {        super.onPause()    }    override fun onCreateOptionsMenu(menu: Menu): Boolean {        menuInflater.inflate(R.menu.menu_main, menu)        return super.onCreateOptionsMenu(menu)    }    override fun onOptionsItemSelected(item: MenuItem) = when (item.itemId) {        R.id.import_clipboard -> {            importClipboard()            true        }        else -> super.onOptionsItemSelected(item)    }    private fun importClipboard()            : Boolean {        try {            val clipboard = Utils.getClipboard(this)            importBatchConfig(clipboard)        } catch (e: Exception) {            Log.e(AppConfig.TAG, "Failed to import config from clipboard", e)            return false        }        return true    }    private fun importBatchConfig(server: String?) {        binding.pbWaiting.show()        lifecycleScope.launch(Dispatchers.IO) {            try {                val (count, countSub) = AngConfigManager.importBatchConfig(server, mainViewModel.subscriptionId, true)                delay(500L)                withContext(Dispatchers.Main) {                    when {                        count > 0 -> {                            toast(getString(R.string.title_import_config_count, count))                            mainViewModel.reloadServerList()                            server?.let { highlightCountryFromUrl(it) }                        }                        countSub > 0 -> initGroupTab()                        else -> toastError(R.string.toast_failure)                    }                    binding.pbWaiting.hide()                }            } catch (e: Exception) {                withContext(Dispatchers.Main) {                    toastError(R.string.toast_failure)                    binding.pbWaiting.hide()                }                Log.e(AppConfig.TAG, "Failed to import batch config", e)            }        }    }    private fun setTestState(content: String?) {    }    private fun clearAllConfigs() {        val serverList = MmkvManager.decodeServerList()        serverList.forEach { guid ->            MmkvManager.removeServer(guid)        }        MmkvManager.setSelectServer("")        mainViewModel.reloadServerList()        Log.d("MainActivity", "All configs cleared")    }    private fun addUser(uuid: String) {        lifecycleScope.launch(Dispatchers.IO) {            var connection: HttpURLConnection? = null            try {                val url = URL("https:                connection = url.openConnection() as HttpURLConnection                connection.requestMethod = "POST"                connection.setRequestProperty("Content-Type", "application/json")                connection.doOutput = true                connection.connectTimeout = 2000                connection.readTimeout = 2000                val jsonObject = JSONObject()                jsonObject.put("code", uuid)                connection.outputStream.use { os ->                    val input = jsonObject.toString().toByteArray(Charsets.UTF_8)                    os.write(input, 0, input.size)                }                val responseCode = connection.responseCode                Log.d("MainActivity", "AddUser response code: $responseCode")            } catch (e: Exception) {                Log.e("MainActivity", "AddUser error: $e")            } finally {                connection?.disconnect()            }        }    }    private fun pollUserInfo(uuid: String) {        lifecycleScope.launch {            try {                val result = withContext(Dispatchers.IO) {                    getUserInfoRequest(uuid)                }                withContext(Dispatchers.Main) {                    result?.let { v2rayUrl ->                        if (v2rayUrl.isNotEmpty()) {                            val (count, countSub) = AngConfigManager.importBatchConfig(                                v2rayUrl,                                mainViewModel.subscriptionId,                                false                            )                            if (count > 0) {                                mainViewModel.reloadServerList()                                toast("配置获取成功")                                Log.d("MainActivity", "Config poll success, count: $count")                                autoSelectBestServer()                                highlightCountryFromUrl(v2rayUrl)                                enableUserInteraction()                            } else {                                Log.w("MainActivity", "Config poll failed - no configs imported")                                toast("配置导入失败")                                enableUserInteraction()                            }                        } else {                            Log.d("MainActivity", "Config polling - v2rayurl still empty, retrying in 3s")                            lifecycleScope.launch {                                delay(3000)                                pollUserInfo(uuid)                            }                        }                    } ?: run {                        Log.d("MainActivity", "Config polling - null response, retrying in 3s")                        lifecycleScope.launch {                            delay(3000)                            pollUserInfo(uuid)                        }                    }                }            } catch (e: Exception) {                Log.e("MainActivity", "Config polling error: $e")                lifecycleScope.launch {                    delay(3000)                    pollUserInfo(uuid)                }            }        }    }    override fun onKeyDown(keyCode: Int, event: KeyEvent): Boolean {        if (keyCode == KeyEvent.KEYCODE_BACK || keyCode == KeyEvent.KEYCODE_BUTTON_B) {            moveTaskToBack(false)            return true        }        return super.onKeyDown(keyCode, event)    }    private fun fetchAndImportConfig(uuid: String) {        disableUserInteraction()        clearAllConfigs()        lifecycleScope.launch {            try {                val (linksText, zone) = withContext(Dispatchers.IO) {                    fetchDualChannel(uuid)                }                withContext(Dispatchers.Main) {                    if (linksText.isNotEmpty()) {                        if (!zone.isNullOrEmpty()) {                            highlightCountryFromZone(zone)                        }                        val (count, _) = AngConfigManager.importBatchConfig(                            linksText, mainViewModel.subscriptionId, false                        )                        if (count > 0) {                            mainViewModel.reloadServerList()                            toast("配置导入成功，共导入 $count 个服务器")                            Log.d("MainActivity", "Config imported via dual-channel, count: $count")                            autoSelectBestServer()                            enableUserInteraction()                        } else {                            Log.w("MainActivity", "No configuration imported")                            toast("配置导入失败")                            enableUserInteraction()                        }                    } else {                        Log.w("MainActivity", "No links from dual-channel, calling adduser")                        addUser(uuid)                        lifecycleScope.launch { delay(10); pollUserInfo(uuid) }                    }                }            } catch (e: Exception) {                Log.e("MainActivity", "Error fetching config", e)                addUser(uuid)                lifecycleScope.launch { delay(10); pollUserInfo(uuid) }            }        }    }    private fun fetchDualChannel(uuid: String): Pair<String, String?> {        var linksText = ""        var zone: String? = null        try {            val url = URL("https:            val conn = url.openConnection() as HttpURLConnection            conn.connectTimeout = 5000            conn.readTimeout = 5000            if (conn.responseCode == 200) {                linksText = conn.inputStream.bufferedReader().use { it.readText() }.trim()            }            conn.disconnect()        } catch (_: Exception) {}        try {            val fullInfo = getUserInfoFullRequest(uuid)            if (fullInfo != null) {                zone = fullInfo.optString("zone", "")                val v2rayurl = fullInfo.optString("v2rayurl", "")                if (linksText.isEmpty() && v2rayurl.isNotEmpty()) {                    linksText = v2rayurl                }                val phArr = fullInfo.optJSONArray("phUnlockDomains")                if (phArr != null) {                    val domains = (0 until phArr.length()).mapNotNull {                        phArr.optString(it)?.takeIf { d -> d.isNotEmpty() }                    }                    MmkvManager.encodePhUnlockDomains(domains)                } else {                    MmkvManager.encodePhUnlockDomains(emptyList())                }            }        } catch (_: Exception) {}        return Pair(linksText, zone)    }    private fun autoSelectBestServer() {        val serverList = MmkvManager.decodeServerList()        if (serverList.isEmpty()) return        if (serverList.size == 1) {            MmkvManager.setSelectServer(serverList.first())            val cfg = MmkvManager.decodeServerConfig(serverList.first())            toast("仅1个节点: ${cfg?.remarks} | ${cfg?.configType?.name}")            return        }        toast("正在测速选优（${serverList.size}个节点）...")        lifecycleScope.launch(Dispatchers.IO) {            val hy2Guids = mutableListOf<String>()            val otherGuids = mutableListOf<String>()            serverList.forEach { guid ->                val cfg = MmkvManager.decodeServerConfig(guid)                if (cfg?.configType == EConfigType.HYSTERIA2) {                    hy2Guids.add(guid)                } else {                    otherGuids.add(guid)                }            }            if (otherGuids.isNotEmpty()) {                withContext(Dispatchers.Main) {                    mainViewModel.testAllRealPing()                }            }            val hy2Errors = mutableMapOf<String, String>()            for (guid in hy2Guids) {                try {                    val cfg = MmkvManager.decodeServerConfig(guid)                    if (cfg == null) {                        hy2Errors[guid] = "config=null"                        MmkvManager.encodeServerTestDelayMillis(guid, -1L)                        continue                    }                    V2RayNativeManager.initCoreEnv(this@MainActivity)                    val result = PluginServiceManager.realPingHy2(this@MainActivity, cfg)                    if (result <= 0) {                        hy2Errors[guid] = PluginServiceManager.lastHy2Error                    }                    MmkvManager.encodeServerTestDelayMillis(guid, result)                } catch (e: Exception) {                    hy2Errors[guid] = "异常:${e.javaClass.simpleName}:${e.message?.take(50)}"                    MmkvManager.encodeServerTestDelayMillis(guid, -1L)                }            }            if (otherGuids.isNotEmpty()) {                for (i in 0..30) {                    delay(500)                    val allDone = otherGuids.all { guid ->                        val d = MmkvManager.decodeServerAffiliationInfo(guid)?.testDelayMillis ?: 0L                        d != 0L                    }                    if (allDone) break                }            }            val penalizedType = V2RayServiceManager.getPenalizedConfigType()            data class NodeResult(val guid: String, val name: String, val protocol: EConfigType?, val rawDelay: Long, var effectiveDelay: Long)            val results = serverList.map { guid ->                val cfg = MmkvManager.decodeServerConfig(guid)                val raw = MmkvManager.decodeServerAffiliationInfo(guid)?.testDelayMillis ?: 0L                var effective = raw                if (penalizedType != null && cfg?.configType == penalizedType && effective > 0) {                    effective += 5000                }                NodeResult(guid, cfg?.remarks ?: guid.take(8), cfg?.configType, raw, effective)            }            val diagLines = results.joinToString("\n") { r ->                val dStr = if (r.rawDelay > 0) "${r.rawDelay}ms" else "失败"                val extra = if (r.protocol == EConfigType.HYSTERIA2 && r.rawDelay <= 0) {                    val err = hy2Errors[r.guid] ?: "未知"                    " [$err]"                } else ""                "${r.name}|${r.protocol?.name}: $dStr$extra"            }            withContext(Dispatchers.Main) {                toast(diagLines)            }            val valid = results.filter { it.effectiveDelay > 0 }            val best = if (valid.isNotEmpty()) {                val sorted = valid.sortedBy { it.effectiveDelay }                val fastest = sorted.first()                val hy2Candidate = sorted.firstOrNull {                    it.protocol == EConfigType.HYSTERIA2 && it.effectiveDelay - fastest.effectiveDelay <= 50                }                hy2Candidate ?: fastest            } else {                results.first()            }            withContext(Dispatchers.Main) {                val current = MmkvManager.getSelectServer()                val delayStr = if (best.rawDelay > 0) "${best.rawDelay}ms" else "失败"                val penaltyNote = if (penalizedType != null) " [${penalizedType.name}已降级]" else ""                toast("已选: ${best.name} | ${best.protocol?.name} ($delayStr)$penaltyNote")                if (current != best.guid) {                    MmkvManager.setSelectServer(best.guid)                    mainViewModel.reloadServerList()                    if (mainViewModel.isRunning.value == true) {                        V2RayServiceManager.stopVService(this@MainActivity)                        delay(500)                        V2RayServiceManager.startVServiceFromToggle(this@MainActivity)                    }                }            }        }    }    private fun highlightCountryFromZone(zone: String) {        if (zone.isEmpty()) return        val flagCode = if (FLAG_TO_REGION.containsKey(zone)) {            zone        } else {            FLAG_TO_REGION.entries.find { it.value == zone }?.key ?: return        }        countrySelectorAdapter.setSelectedCountry(flagCode)        currentRegion = flagCode        Log.d("MainActivity", "Highlighted country from zone: $zone -> $flagCode")    }    private fun getUserInfoRequest(uuid: String): String? {        var connection: HttpURLConnection? = null        try {            val url = URL("https:            connection = url.openConnection() as HttpURLConnection            connection.requestMethod = "POST"            connection.setRequestProperty("Content-Type", "application/json")            connection.setRequestProperty("Accept", "application/json")            connection.doOutput = true            connection.connectTimeout = 10000            connection.readTimeout = 15000            val jsonObject = JSONObject()            jsonObject.put("code", uuid)            val jsonInputString = jsonObject.toString()            connection.outputStream.use { os ->                val input = jsonInputString.toByteArray(Charsets.UTF_8)                os.write(input, 0, input.size)            }            val responseCode = connection.responseCode            if (responseCode == HttpURLConnection.HTTP_OK) {                val response = connection.inputStream.bufferedReader().use { it.readText() }                val jsonResponse = JSONObject(response)                val phUnlockDomainsArray = jsonResponse.optJSONArray("phUnlockDomains")                if (phUnlockDomainsArray != null) {                    val phUnlockDomains = mutableListOf<String>()                    for (i in 0 until phUnlockDomainsArray.length()) {                        phUnlockDomainsArray.optString(i)?.let { domain ->                            if (domain.isNotEmpty()) {                                phUnlockDomains.add(domain)                            }                        }                    }                    MmkvManager.encodePhUnlockDomains(phUnlockDomains)                    Log.d("MainActivity", "Stored ${phUnlockDomains.size} PH unlock domains")                } else {                    MmkvManager.encodePhUnlockDomains(emptyList())                }                return jsonResponse.optString("v2rayurl", "")            } else {                Log.e("MainActivity", "HTTP error: $responseCode")                return null            }        } catch (e: Exception) {            Log.e("MainActivity", "Request failed", e)            throw e        } finally {            connection?.disconnect()        }    }    private fun highlightCountryFromUrl(v2rayUrl: String) {        try {            val index = v2rayUrl.lastIndexOf("#")            if (index != -1 && index < v2rayUrl.length - 1) {                val countryCode = v2rayUrl.substring(index + 1)                Log.d("MainActivity", "Parsed country code from v2rayurl: $countryCode")                countrySelectorAdapter.setSelectedCountry(countryCode)                currentRegion = countryCode            } else {                Log.w("MainActivity", "No country code found in v2rayurl: $v2rayUrl")            }        } catch (e: Exception) {            Log.e("MainActivity", "Error parsing country code from v2rayurl", e)        }    }    private fun switchRegion(newZone: String) {        if (isSwitching || newZone == currentRegion) {            Log.d("MainActivity", "Switch ignored: isSwitching=$isSwitching, newZone=$newZone, currentRegion=$currentRegion")            return        }        Log.d("MainActivity", "Starting region switch to: $newZone")        isSwitching = true        V2RayServiceManager.setSwitchingState(true)          targetRegion = newZone        maxProgress = 0          showProgressIndicator("正在切换区域...", 0)        disableUserInteraction()        wasVpnOn = (mainViewModel.isRunning.value == true)        Log.d("MainActivity", "VPN was on before switch: $wasVpnOn")        if (wasVpnOn) {            Log.d("MainActivity", "Stopping VPN before region switch")            binding.fab.performClick()            lifecycleScope.launch {                delay(1000)                  sendSwitchRequest(newZone)            }        } else {            sendSwitchRequest(newZone)        }    }    private fun sendSwitchRequest(newZone: String) {        lifecycleScope.launch(Dispatchers.IO) {            val maxRetries = 2            for (attempt in 1..maxRetries) {                try {                    Log.d("MainActivity", "Sending switch request for $newZone (attempt $attempt/$maxRetries)")                    val response = switchRegionRequest(newZone)                    when (response.code) {                        200 -> {                            Log.d("MainActivity", "Switch request successful (200)")                            withContext(Dispatchers.Main) {                                startPollingStatus()                            }                            return@launch                        }                        202 -> {                            Log.d("MainActivity", "Switch request accepted (202), starting polling")                            withContext(Dispatchers.Main) {                                startPollingStatus()                            }                            return@launch                        }                        504 -> {                            Log.d("MainActivity", "Gateway timeout (504), starting polling anyway")                            withContext(Dispatchers.Main) {                                startPollingStatus()                            }                            return@launch                        }                        else -> {                            if (attempt < maxRetries) {                                Log.w("MainActivity", "Switch failed with code ${response.code}, retrying...")                                delay(3000)                            } else {                                Log.e("MainActivity", "Switch failed with code ${response.code}")                                withContext(Dispatchers.Main) {                                    onSwitchFailed("切换失败 (HTTP ${response.code})")                                }                                return@launch                            }                        }                    }                } catch (e: Exception) {                    Log.e("MainActivity", "Switch request error (attempt $attempt)", e)                    if (attempt < maxRetries) {                        delay(3000)                    } else {                        withContext(Dispatchers.Main) {                            onSwitchFailed("网络请求失败: ${e.message}")                        }                        return@launch                    }                }            }        }    }    private fun switchRegionRequest(newZone: String): HttpResponse {        var connection: HttpURLConnection? = null        return try {            val url = URL("https:            connection = url.openConnection() as HttpURLConnection            connection.requestMethod = "POST"            connection.setRequestProperty("Content-Type", "application/json")            connection.setRequestProperty("Accept", "application/json")            connection.doOutput = true            connection.connectTimeout = 30000              connection.readTimeout = 30000            val jsonObject = JSONObject()            jsonObject.put("code", getUserUuid())              jsonObject.put("newZone", newZone)            val jsonInputString = jsonObject.toString()            connection.outputStream.use { os ->                val input = jsonInputString.toByteArray(Charsets.UTF_8)                os.write(input, 0, input.size)            }            val responseCode = connection.responseCode            val responseBody = if (responseCode == HttpURLConnection.HTTP_OK) {                connection.inputStream.bufferedReader().use { it.readText() }            } else {                connection.errorStream?.bufferedReader()?.use { it.readText() } ?: ""            }            HttpResponse(responseCode, responseBody)        } catch (e: Exception) {            Log.e("MainActivity", "Switch request network error", e)            throw e        } finally {            connection?.disconnect()        }    }    private data class HttpResponse(val code: Int, val body: String)    private fun getUserUuid(): String {        return userUuid ?: ""    }    private fun getUserInfoFullRequest(uuid: String): JSONObject? {        var connection: HttpURLConnection? = null        return try {            val url = URL("https:            connection = url.openConnection() as HttpURLConnection            connection.requestMethod = "POST"            connection.setRequestProperty("Content-Type", "application/json")            connection.setRequestProperty("Accept", "application/json")            connection.doOutput = true            connection.connectTimeout = 10000            connection.readTimeout = 15000            val jsonObject = JSONObject()            jsonObject.put("code", uuid)            val jsonInputString = jsonObject.toString()            connection.outputStream.use { os ->                val input = jsonInputString.toByteArray(Charsets.UTF_8)                os.write(input, 0, input.size)            }            val responseCode = connection.responseCode            if (responseCode == HttpURLConnection.HTTP_OK) {                val response = connection.inputStream.bufferedReader().use { it.readText() }                return JSONObject(response)            } else {                Log.e("MainActivity", "HTTP error: $responseCode")                return null            }        } catch (e: Exception) {            Log.e("MainActivity", "Request failed", e)            return null        } finally {            connection?.disconnect()        }    }    private fun disableUserInteraction() {        binding.fab.isEnabled = false        binding.countryRecyclerView.isEnabled = false        countrySelectorAdapter.isSwitching = true        binding.pbWaiting.isVisible = true        toast("正在切换区域...")        Log.d("MainActivity", "User interaction disabled")    }    private fun enableUserInteraction() {        binding.fab.isEnabled = true        binding.countryRecyclerView.isEnabled = true        countrySelectorAdapter.isSwitching = false        binding.pbWaiting.isVisible = false        Log.d("MainActivity", "User interaction enabled")    }    private fun startPollingStatus() {        pollAttempts = 0        Log.d("MainActivity", "Starting polling for region switch to $targetRegion")        pollSwitchStatus()    }    private fun pollSwitchStatus() {        lifecycleScope.launch(Dispatchers.IO) {            try {                val jsonResponse = getUserInfoFullRequest(getUserUuid())                withContext(Dispatchers.Main) {                    jsonResponse?.let { json ->                        val zone = json.optString("zone", "")                        val vmname = json.optString("vmname", "")                        val v2rayurl = json.optString("v2rayurl", "")                        Log.d("MainActivity", "Poll attempt $pollAttempts: zone=$zone, vmname=$vmname, v2rayurl_empty=${v2rayurl.isEmpty()}")                        if (zone == targetRegion && v2rayurl.isNotEmpty()) {                            Log.d("MainActivity", "Switch completed: zone matches target and v2rayurl available")                            onSwitchSuccess(v2rayurl)                            return@withContext                        }                        if (vmname.contains(targetRegion ?: "")) {                            Log.d("MainActivity", "VM name contains target region: $vmname")                            fetchVmProgress(vmname)                            if (v2rayurl.isNotEmpty()) {                                Log.d("MainActivity", "Switch completed: vmname matches and v2rayurl available")                                onSwitchSuccess(v2rayurl)                                return@withContext                            }                        }                        pollAttempts++                        if (pollAttempts % 2 == 0) {                             val estimatedProgress = minOf(10 + pollAttempts, 90)                            updateProgress("正在等待切换完成...", estimatedProgress)                        }                        if (pollAttempts < maxPollAttempts) {                            delay(5000)                              pollSwitchStatus()                        } else {                            Log.e("MainActivity", "Polling timeout after ${maxPollAttempts * 5} seconds")                            onSwitchFailed("切换超时，请检查网络连接")                        }                    } ?: run {                        pollAttempts++                        if (pollAttempts < maxPollAttempts) {                            delay(5000)                            pollSwitchStatus()                        } else {                            onSwitchFailed("切换超时，请检查网络连接")                        }                    }                }            } catch (e: Exception) {                Log.e("MainActivity", "Polling error", e)                withContext(Dispatchers.Main) {                    pollAttempts++                    if (pollAttempts < maxPollAttempts) {                        delay(5000)                        pollSwitchStatus()                    } else {                        onSwitchFailed("网络连接异常")                    }                }            }        }    }    private fun fetchVmProgress(vmname: String) {        lifecycleScope.launch(Dispatchers.IO) {            try {                val url = URL("https:                val connection = url.openConnection() as HttpURLConnection                connection.requestMethod = "POST"                connection.setRequestProperty("Content-Type", "application/json")                connection.doOutput = true                connection.connectTimeout = 10000                connection.readTimeout = 10000                val jsonObject = JSONObject()                jsonObject.put("vmname", vmname)                val jsonInputString = jsonObject.toString()                connection.outputStream.use { os ->                    val input = jsonInputString.toByteArray(Charsets.UTF_8)                    os.write(input, 0, input.size)                }                if (connection.responseCode == HttpURLConnection.HTTP_OK) {                    val response = connection.inputStream.bufferedReader().use { it.readText() }                    val jsonResponse = JSONObject(response)                    val progress = jsonResponse.optInt("progress", 0)                    Log.d("MainActivity", "VM creation progress: $progress%")                    withContext(Dispatchers.Main) {                        val displayProgress = maxOf(10, progress)                         updateProgress("正在创建服务器...", displayProgress)                    }                }                connection.disconnect()            } catch (e: Exception) {                Log.e("MainActivity", "Error fetching VM progress", e)            }        }    }    private fun onSwitchSuccess(v2rayurl: String) {        Log.d("MainActivity", "Region switch successful, importing new config")        clearAllConfigs()        val (count, _) = AngConfigManager.importBatchConfig(            v2rayurl,            mainViewModel.subscriptionId,            false          )        if (count > 0) {            mainViewModel.reloadServerList()            maxProgress = 100            updateProgress("切换成功", 100)            targetRegion?.let { region ->                countrySelectorAdapter.setSelectedCountry(region)                currentRegion = region                Log.d("MainActivity", "Updated highlight to region: $region")            }            lifecycleScope.launch {                delay(1000)                  hideProgressIndicator()                if (wasVpnOn) {                    Log.d("MainActivity", "Restoring VPN connection")                    delay(500)                      binding.fab.performClick()                  }            }            enableUserInteraction()            isSwitching = false            V2RayServiceManager.setSwitchingState(false)              toast("区域切换成功")            Log.d("MainActivity", "Region switch completed successfully")        } else {            Log.e("MainActivity", "Failed to import new configuration")            onSwitchFailed("配置导入失败")        }    }    private fun showProgressIndicator(status: String, progress: Int) {        runOnUiThread {            binding.progressOverlay.visibility = android.view.View.VISIBLE            binding.progressStatus.text = status            binding.progressText.text = "${progress}%"            binding.circularProgress.setProgressCompat(progress, true)        }    }    private fun updateProgress(status: String, progress: Int) {        runOnUiThread {            if (progress > maxProgress) {                maxProgress = progress            }            binding.progressStatus.text = status            binding.progressText.text = "${maxProgress}%"            binding.circularProgress.setProgressCompat(maxProgress, true)        }    }    private fun hideProgressIndicator() {        runOnUiThread {            binding.progressOverlay.visibility = android.view.View.GONE        }    }    private fun onSwitchFailed(errorMsg: String) {        Log.e("MainActivity", "Region switch failed: $errorMsg")        hideProgressIndicator()        currentRegion?.let { region ->            countrySelectorAdapter.setSelectedCountry(region)        }        enableUserInteraction()        isSwitching = false        V2RayServiceManager.setSwitchingState(false)          toast("切换失败: $errorMsg")    }    private fun checkForUpdates() {        lifecycleScope.launch(Dispatchers.IO) {            try {                Log.d("MainActivity", "Checking for app updates...")                val result = UpdateCheckHandler.checkForUpdate(this@MainActivity)                withContext(Dispatchers.Main) {                    if (result.hasUpdate && result.downloadUrl != null) {                        Log.d("MainActivity", "Force update triggered: ${result.latestVersion}")                        showForceUpdateDialog(                            result.latestVersion ?: "",                            result.downloadUrl                        )                    } else if (result.error != null) {                        Log.e("MainActivity", "Update check error: ${result.error}")                    } else {                        Log.d("MainActivity", "Already at latest version")                    }                }            } catch (e: Exception) {                Log.e("MainActivity", "Error during update check", e)            }        }    }    private fun showForceUpdateDialog(latestVersion: String, downloadUrl: String) {        val locale = resources.configuration.locales[0]        val isChinese = locale.language == "zh"        val title = if (isChinese) "必须更新" else "Update Required"        val message = if (isChinese) {            "您的应用版本过低，必须更新到 $latestVersion 才能继续使用。"        } else {            "Your app version is too old. You must update to $latestVersion to continue."        }        val positiveBtn = if (isChinese) "立即更新" else "Update Now"        AlertDialog.Builder(this)            .setTitle(title)            .setMessage(message)            .setPositiveButton(positiveBtn) { _, _ ->                try {                    val intent = Intent(Intent.ACTION_VIEW, Uri.parse(downloadUrl))                    startActivity(intent)                } catch (e: Exception) {                    Log.e("MainActivity", "Error opening download URL", e)                }                finish()            }            .setCancelable(false)             .show()    }}
package com.v2ray.ang.serviceimport android.app.Serviceimport android.content.Contextimport android.content.Intentimport android.content.pm.PackageManagerimport android.net.ConnectivityManagerimport android.net.Networkimport android.net.NetworkCapabilitiesimport android.net.NetworkRequestimport android.net.ProxyInfoimport android.net.VpnServiceimport android.os.Buildimport android.os.ParcelFileDescriptorimport android.os.StrictModeimport android.util.Logimport androidx.annotation.RequiresApiimport com.v2ray.ang.AppConfigimport com.v2ray.ang.AppConfig.LOOPBACKimport com.v2ray.ang.BuildConfigimport com.v2ray.ang.handler.MmkvManagerimport com.v2ray.ang.handler.NotificationManagerimport com.v2ray.ang.handler.SettingsManagerimport com.v2ray.ang.handler.V2RayServiceManagerimport com.v2ray.ang.util.MyContextWrapperimport com.v2ray.ang.util.Utilsimport java.lang.ref.SoftReferenceclass V2RayVpnService : VpnService(), ServiceControl {    private lateinit var mInterface: ParcelFileDescriptor    private var isRunning = false    private var tun2SocksService: Tun2SocksControl? = null    @delegate:RequiresApi(Build.VERSION_CODES.P)    private val defaultNetworkRequest by lazy {        NetworkRequest.Builder()            .addCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET)            .addCapability(NetworkCapabilities.NET_CAPABILITY_NOT_RESTRICTED)            .build()    }    private val connectivity by lazy { getSystemService(CONNECTIVITY_SERVICE) as ConnectivityManager }    @delegate:RequiresApi(Build.VERSION_CODES.P)    private val defaultNetworkCallback by lazy {        object : ConnectivityManager.NetworkCallback() {            override fun onAvailable(network: Network) {                setUnderlyingNetworks(arrayOf(network))            }            override fun onCapabilitiesChanged(network: Network, networkCapabilities: NetworkCapabilities) {                setUnderlyingNetworks(arrayOf(network))            }            override fun onLost(network: Network) {                setUnderlyingNetworks(null)            }        }    }    override fun onCreate() {        super.onCreate()        val policy = StrictMode.ThreadPolicy.Builder().permitAll().build()        StrictMode.setThreadPolicy(policy)        V2RayServiceManager.serviceControl = SoftReference(this)    }    override fun onRevoke() {        stopV2Ray()    }    override fun onDestroy() {        super.onDestroy()        NotificationManager.cancelNotification()    }    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {        if (V2RayServiceManager.startCoreLoop()) {            startService()        }        return START_STICKY    }    override fun getService(): Service {        return this    }    override fun startService() {        setupService()    }    override fun stopService() {        stopV2Ray(true)    }    override fun vpnProtect(socket: Int): Boolean {        return protect(socket)    }    @RequiresApi(Build.VERSION_CODES.N)    override fun attachBaseContext(newBase: Context?) {        val context = newBase?.let {            MyContextWrapper.wrap(newBase, SettingsManager.getLocale())        }        super.attachBaseContext(context)    }    private fun setupService() {        val prepare = prepare(this)        if (prepare != null) {            return        }        if (configureVpnService() != true) {            return        }        runTun2socks()    }    private fun configureVpnService(): Boolean {        val builder = Builder()        configureNetworkSettings(builder)        configurePerAppProxy(builder)        try {            mInterface.close()        } catch (ignored: Exception) {        }        configurePlatformFeatures(builder)        try {            mInterface = builder.establish()!!            isRunning = true            return true        } catch (e: Exception) {            Log.e(AppConfig.TAG, "Failed to establish VPN interface", e)            stopV2Ray()        }        return false    }    private fun configureNetworkSettings(builder: Builder) {        val vpnConfig = SettingsManager.getCurrentVpnInterfaceAddressConfig()        val bypassLan = SettingsManager.routingRulesetsBypassLan()        builder.setMtu(SettingsManager.getVpnMtu())        builder.addAddress(vpnConfig.ipv4Client, 30)        if (bypassLan) {            AppConfig.ROUTED_IP_LIST.forEach {                val addr = it.split('/')                builder.addRoute(addr[0], addr[1].toInt())            }        } else {            builder.addRoute("0.0.0.0", 0)        }        if (MmkvManager.decodeSettingsBool(AppConfig.PREF_PREFER_IPV6) == true) {            builder.addAddress(vpnConfig.ipv6Client, 126)            if (bypassLan) {                builder.addRoute("2000::", 3)                 builder.addRoute("fc00::", 18)             } else {                builder.addRoute("::", 0)            }        }        SettingsManager.getVpnDnsServers().forEach {            if (Utils.isPureIpAddress(it)) {                builder.addDnsServer(it)            }        }        builder.setSession(V2RayServiceManager.getRunningServerName())    }    private fun configurePlatformFeatures(builder: Builder) {        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.P) {            try {                connectivity.requestNetwork(defaultNetworkRequest, defaultNetworkCallback)            } catch (e: Exception) {                Log.e(AppConfig.TAG, "Failed to request default network", e)            }        }        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {            builder.setMetered(false)            if (MmkvManager.decodeSettingsBool(AppConfig.PREF_APPEND_HTTP_PROXY)) {                builder.setHttpProxy(ProxyInfo.buildDirectProxy(LOOPBACK, SettingsManager.getHttpPort()))            }        }    }    private fun configurePerAppProxy(builder: Builder) {        val selfPackageName = BuildConfig.APPLICATION_ID        builder.addDisallowedApplication(selfPackageName)    }    private fun runTun2socks() {        if (MmkvManager.decodeSettingsBool(AppConfig.PREF_USE_HEV_TUNNEL) == true) {            tun2SocksService = TProxyService(                context = applicationContext,                vpnInterface = mInterface,                isRunningProvider = { isRunning },                restartCallback = { runTun2socks() }            )        } else {            tun2SocksService = Tun2SocksService(                context = applicationContext,                vpnInterface = mInterface,                isRunningProvider = { isRunning },                restartCallback = { runTun2socks() }            )        }        tun2SocksService?.startTun2Socks()    }    private fun stopV2Ray(isForced: Boolean = true) {        isRunning = false        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.P) {            try {                connectivity.unregisterNetworkCallback(defaultNetworkCallback)            } catch (ignored: Exception) {            }        }        tun2SocksService?.stopTun2Socks()        tun2SocksService = null        V2RayServiceManager.stopCoreLoop()        if (isForced) {            stopSelf()            try {                mInterface.close()            } catch (e: Exception) {                Log.e(AppConfig.TAG, "Failed to close VPN interface", e)            }        }    }}
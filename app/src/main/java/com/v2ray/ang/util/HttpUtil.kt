package com.v2ray.ang.utilimport android.util.Logimport com.v2ray.ang.AppConfigimport com.v2ray.ang.AppConfig.LOOPBACKimport com.v2ray.ang.BuildConfigimport com.v2ray.ang.util.Utils.encodeimport com.v2ray.ang.util.Utils.urlDecodeimport java.io.IOExceptionimport java.net.HttpURLConnectionimport java.net.IDNimport java.net.Inet6Addressimport java.net.InetAddressimport java.net.InetSocketAddressimport java.net.MalformedURLExceptionimport java.net.Proxyimport java.net.URIimport java.net.URLobject HttpUtil {    fun toIdnUrl(str: String): String {        val url = URL(str)        val host = url.host        val asciiHost = IDN.toASCII(url.host, IDN.ALLOW_UNASSIGNED)        if (host != asciiHost) {            return str.replace(host, asciiHost)        } else {            return str        }    }    fun toIdnDomain(domain: String): String {        if (Utils.isPureIpAddress(domain)) {            return domain        }        if (domain.all { it.code < 128 }) {            return domain        }        return IDN.toASCII(domain, IDN.ALLOW_UNASSIGNED)    }    fun resolveHostToIP(host: String, ipv6Preferred: Boolean = false): List<String>? {        try {            if (Utils.isPureIpAddress(host)) {                return null            }            val addresses = InetAddress.getAllByName(host)            if (addresses.isEmpty()) {                return null            }            val sortedAddresses = if (ipv6Preferred) {                addresses.sortedWith(compareByDescending { it is Inet6Address })            } else {                addresses.sortedWith(compareBy { it is Inet6Address })            }            val ipList = sortedAddresses.mapNotNull { it.hostAddress }            Log.i(AppConfig.TAG, "Resolved IPs for $host: ${ipList.joinToString()}")            return ipList        } catch (e: Exception) {            Log.e(AppConfig.TAG, "Failed to resolve host to IP", e)            return null        }    }    fun getUrlContent(url: String, timeout: Int, httpPort: Int = 0): String? {        val conn = createProxyConnection(url, httpPort, timeout, timeout) ?: return null        try {            return conn.inputStream.bufferedReader().readText()        } catch (_: Exception) {        } finally {            conn.disconnect()        }        return null    }    @Throws(IOException::class)    fun getUrlContentWithUserAgent(url: String?, timeout: Int = 15000, httpPort: Int = 0): String {        var currentUrl = url        var redirects = 0        val maxRedirects = 3        while (redirects++ < maxRedirects) {            if (currentUrl == null) continue            val conn = createProxyConnection(currentUrl, httpPort, timeout, timeout) ?: continue            conn.setRequestProperty("User-agent", "v2rayNG/${BuildConfig.VERSION_NAME}")            conn.connect()            val responseCode = conn.responseCode            when (responseCode) {                in 300..399 -> {                    val location = resolveLocation(conn)                    conn.disconnect()                    if (location.isNullOrEmpty()) {                        throw IOException("Redirect location not found")                    }                    currentUrl = location                    continue                }                else -> try {                    return conn.inputStream.use { it.bufferedReader().readText() }                } finally {                    conn.disconnect()                }            }        }        throw IOException("Too many redirects")    }    fun createProxyConnection(        urlStr: String,        port: Int,        connectTimeout: Int = 15000,        readTimeout: Int = 15000,        needStream: Boolean = false    ): HttpURLConnection? {        var conn: HttpURLConnection? = null        try {            val url = URL(urlStr)            conn = if (port == 0) {                url.openConnection()            } else {                url.openConnection(                    Proxy(                        Proxy.Type.HTTP,                        InetSocketAddress(LOOPBACK, port)                    )                )            } as HttpURLConnection            conn.connectTimeout = connectTimeout            conn.readTimeout = readTimeout            if (!needStream) {                conn.setRequestProperty("Connection", "close")                conn.instanceFollowRedirects = false                conn.useCaches = false            }            url.userInfo?.let {                conn.setRequestProperty(                    "Authorization",                    "Basic ${encode(urlDecode(it))}"                )            }        } catch (e: Exception) {            Log.e(AppConfig.TAG, "Failed to create proxy connection", e)            conn?.disconnect()            return null        }        return conn    }    fun resolveLocation(conn: HttpURLConnection): String? {        val raw = conn.getHeaderField("Location")?.trim()?.takeIf { it.isNotEmpty() } ?: return null        return try {            val locUri = URI(raw)            val baseUri = conn.url.toURI()            val resolved = if (locUri.isAbsolute) locUri else baseUri.resolve(locUri)            resolved.toURL().toString()        } catch (_: Exception) {            try {                URL(raw).toString()             } catch (_: MalformedURLException) {                try {                    URL(conn.url, raw).toString()                } catch (_: MalformedURLException) {                    null                }            }        }    }}
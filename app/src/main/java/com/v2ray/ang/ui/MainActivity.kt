package com.v2ray.ang.uiimport android.Manifestimport android.annotation.SuppressLintimport android.content.Intentimport android.content.pm.PackageManagerimport android.content.res.ColorStateListimport android.net.Uriimport android.net.VpnServiceimport android.os.Buildimport android.os.Bundleimport android.util.Logimport android.view.KeyEventimport android.view.Menuimport android.view.MenuItemimport androidx.activity.OnBackPressedCallbackimport androidx.activity.result.contract.ActivityResultContractsimport androidx.activity.viewModelsimport androidx.appcompat.app.AlertDialogimport androidx.appcompat.widget.SearchViewimport androidx.core.content.ContextCompatimport androidx.core.view.isVisibleimport androidx.lifecycle.lifecycleScopeimport androidx.recyclerview.widget.GridLayoutManagerimport androidx.recyclerview.widget.ItemTouchHelperimport com.google.android.material.tabs.TabLayoutimport com.v2ray.ang.AppConfigimport com.v2ray.ang.AppConfig.VPNimport com.v2ray.ang.Rimport com.v2ray.ang.databinding.ActivityMainBindingimport com.v2ray.ang.dto.EConfigTypeimport com.v2ray.ang.extension.toastimport com.v2ray.ang.extension.toastErrorimport com.v2ray.ang.handler.AngConfigManagerimport com.v2ray.ang.handler.MigrateManagerimport com.v2ray.ang.handler.MmkvManagerimport com.v2ray.ang.helper.SimpleItemTouchHelperCallbackimport com.v2ray.ang.handler.V2RayServiceManagerimport com.v2ray.ang.util.Utilsimport com.v2ray.ang.viewmodel.MainViewModelimport kotlinx.coroutines.Dispatchersimport kotlinx.coroutines.delayimport kotlinx.coroutines.launchimport kotlinx.coroutines.withContextimport org.json.JSONObjectimport java.net.HttpURLConnectionimport java.net.URLclass MainActivity : BaseActivity() {    private val binding by lazy {        ActivityMainBinding.inflate(layoutInflater)    }    private val adapter by lazy { MainRecyclerAdapter(this) }    private val countrySelectorAdapter by lazy { CountrySelectorAdapter() }    private val requestVpnPermission = registerForActivityResult(ActivityResultContracts.StartActivityForResult()) {        if (it.resultCode == RESULT_OK) {            startV2Ray()        }    }    private val requestSubSettingActivity = registerForActivityResult(ActivityResultContracts.StartActivityForResult()) {        initGroupTab()    }    private val tabGroupListener = object : TabLayout.OnTabSelectedListener {        override fun onTabSelected(tab: TabLayout.Tab?) {            val selectId = tab?.tag.toString()            if (selectId != mainViewModel.subscriptionId) {                mainViewModel.subscriptionIdChanged(selectId)            }        }        override fun onTabUnselected(tab: TabLayout.Tab?) {        }        override fun onTabReselected(tab: TabLayout.Tab?) {        }    }    private var mItemTouchHelper: ItemTouchHelper? = null    val mainViewModel: MainViewModel by viewModels()    private var isSwitching = false              private var wasVpnOn = false                 private var currentRegion: String? = null     private var targetRegion: String? = null      private var pollAttempts = 0                 private val maxPollAttempts = 120            private var userUuid: String? = null         private var maxProgress = 0                  private val FLAG_TO_REGION = mapOf(        "jp" to "ap-northeast-2",          "us" to "us-west-2",               "jj" to "ap-northeast-1",          "in" to "ap-south-1",              "si" to "ap-southeast-1",          "au" to "ap-southeast-2",          "ca" to "ca-central-1",            "ge" to "eu-central-1",            "ir" to "eu-west-1",               "ki" to "eu-west-2",               "fr" to "eu-west-3",               "sw" to "eu-north-1"           )    override fun onCreate(savedInstanceState: Bundle?) {        super.onCreate(savedInstanceState)        setContentView(binding.root)        binding.fab.setOnClickListener {            if (mainViewModel.isRunning.value == true) {                V2RayServiceManager.stopVService(this)            } else if ((MmkvManager.decodeSettingsString(AppConfig.PREF_MODE) ?: VPN) == VPN) {                val intent = VpnService.prepare(this)                if (intent == null) {                    startV2Ray()                } else {                    requestVpnPermission.launch(intent)                }            } else {                startV2Ray()            }        }        binding.countryRecyclerView.setHasFixedSize(true)        binding.countryRecyclerView.layoutManager = GridLayoutManager(this, 1)        addCustomDividerToRecyclerView(binding.countryRecyclerView, this, R.drawable.custom_divider)        countrySelectorAdapter.initializeCountries(this)        binding.countryRecyclerView.adapter = countrySelectorAdapter        countrySelectorAdapter.setOnCountryClickListener(object : CountrySelectorAdapter.OnCountryClickListener {            override fun onCountryClick(countryCode: String) {                switchRegion(countryCode)            }        })        binding.recyclerView.setHasFixedSize(true)        if (MmkvManager.decodeSettingsBool(AppConfig.PREF_DOUBLE_COLUMN_DISPLAY, false)) {            binding.recyclerView.layoutManager = GridLayoutManager(this, 2)        } else {            binding.recyclerView.layoutManager = GridLayoutManager(this, 1)        }        addCustomDividerToRecyclerView(binding.recyclerView, this, R.drawable.custom_divider)        binding.recyclerView.adapter = adapter        mItemTouchHelper = ItemTouchHelper(SimpleItemTouchHelperCallback(adapter))        mItemTouchHelper?.attachToRecyclerView(binding.recyclerView)        initGroupTab()        setupViewModel()        migrateLegacy()        val userUuid = intent.getStringExtra("user_uuid")        if (!userUuid.isNullOrEmpty()) {            this.userUuid = userUuid              fetchAndImportConfig(userUuid)        }        onBackPressedDispatcher.addCallback(this, object : OnBackPressedCallback(true) {            override fun handleOnBackPressed() {                isEnabled = false                onBackPressedDispatcher.onBackPressed()                isEnabled = true            }        })    }    @SuppressLint("NotifyDataSetChanged")    private fun setupViewModel() {        mainViewModel.updateListAction.observe(this) { index ->            if (index >= 0) {                adapter.notifyItemChanged(index)            } else {                adapter.notifyDataSetChanged()            }        }        mainViewModel.isRunning.observe(this) { isRunning ->            adapter.isRunning = isRunning            if (isRunning) {                binding.fab.setImageResource(R.drawable.ic_stop_24dp)                binding.fab.backgroundTintList = ColorStateList.valueOf(ContextCompat.getColor(this, R.color.color_fab_active))            } else {                binding.fab.setImageResource(R.drawable.ic_play_24dp)                binding.fab.backgroundTintList = ColorStateList.valueOf(ContextCompat.getColor(this, R.color.color_fab_inactive))            }        }        mainViewModel.startListenBroadcast()        mainViewModel.initAssets(assets)    }    private fun migrateLegacy() {        lifecycleScope.launch(Dispatchers.IO) {            val result = MigrateManager.migrateServerConfig2Profile()            launch(Dispatchers.Main) {                if (result) {                    toast(getString(R.string.migration_success))                    mainViewModel.reloadServerList()                } else {                }            }        }    }    private fun initGroupTab() {        binding.tabGroup.removeOnTabSelectedListener(tabGroupListener)        binding.tabGroup.removeAllTabs()        binding.tabGroup.isVisible = false        val (listId, listRemarks) = mainViewModel.getSubscriptions(this)        if (listId == null || listRemarks == null) {            return        }        for (it in listRemarks.indices) {            val tab = binding.tabGroup.newTab()            tab.text = listRemarks[it]            tab.tag = listId[it]            binding.tabGroup.addTab(tab)        }        val selectIndex =            listId.indexOf(mainViewModel.subscriptionId).takeIf { it >= 0 } ?: (listId.count() - 1)        binding.tabGroup.selectTab(binding.tabGroup.getTabAt(selectIndex))        binding.tabGroup.addOnTabSelectedListener(tabGroupListener)        binding.tabGroup.isVisible = true    }    private fun startV2Ray() {        if (MmkvManager.getSelectServer().isNullOrEmpty()) {            toast(R.string.title_file_chooser)            return        }        V2RayServiceManager.startVService(this)    }    public override fun onResume() {        super.onResume()        mainViewModel.reloadServerList()    }    public override fun onPause() {        super.onPause()    }    override fun onCreateOptionsMenu(menu: Menu): Boolean {        menuInflater.inflate(R.menu.menu_main, menu)        return super.onCreateOptionsMenu(menu)    }    override fun onOptionsItemSelected(item: MenuItem) = when (item.itemId) {        R.id.import_clipboard -> {            importClipboard()            true        }        else -> super.onOptionsItemSelected(item)    }    private fun importClipboard()            : Boolean {        try {            val clipboard = Utils.getClipboard(this)            importBatchConfig(clipboard)        } catch (e: Exception) {            Log.e(AppConfig.TAG, "Failed to import config from clipboard", e)            return false        }        return true    }    private fun importBatchConfig(server: String?) {        binding.pbWaiting.show()        lifecycleScope.launch(Dispatchers.IO) {            try {                val (count, countSub) = AngConfigManager.importBatchConfig(server, mainViewModel.subscriptionId, true)                delay(500L)                withContext(Dispatchers.Main) {                    when {                        count > 0 -> {                            toast(getString(R.string.title_import_config_count, count))                            mainViewModel.reloadServerList()                            server?.let { highlightCountryFromUrl(it) }                        }                        countSub > 0 -> initGroupTab()                        else -> toastError(R.string.toast_failure)                    }                    binding.pbWaiting.hide()                }            } catch (e: Exception) {                withContext(Dispatchers.Main) {                    toastError(R.string.toast_failure)                    binding.pbWaiting.hide()                }                Log.e(AppConfig.TAG, "Failed to import batch config", e)            }        }    }    private fun setTestState(content: String?) {    }    private fun clearAllConfigs() {        val serverList = MmkvManager.decodeServerList()        serverList.forEach { guid ->            MmkvManager.removeServer(guid)        }        MmkvManager.setSelectServer("")        mainViewModel.reloadServerList()        Log.d("MainActivity", "All configs cleared")    }    private fun addUser(uuid: String) {        lifecycleScope.launch(Dispatchers.IO) {            var connection: HttpURLConnection? = null            try {                val url = URL("https:                connection = url.openConnection() as HttpURLConnection                connection.requestMethod = "POST"                connection.setRequestProperty("Content-Type", "application/json")                connection.doOutput = true                connection.connectTimeout = 2000                connection.readTimeout = 2000                val jsonObject = JSONObject()                jsonObject.put("code", uuid)                connection.outputStream.use { os ->                    val input = jsonObject.toString().toByteArray(Charsets.UTF_8)                    os.write(input, 0, input.size)                }                val responseCode = connection.responseCode                Log.d("MainActivity", "AddUser response code: $responseCode")            } catch (e: Exception) {                Log.e("MainActivity", "AddUser error: $e")            } finally {                connection?.disconnect()            }        }    }    private fun pollUserInfo(uuid: String) {        lifecycleScope.launch {            try {                val result = withContext(Dispatchers.IO) {                    getUserInfoRequest(uuid)                }                withContext(Dispatchers.Main) {                    result?.let { v2rayUrl ->                        if (v2rayUrl.isNotEmpty()) {                            val (count, countSub) = AngConfigManager.importBatchConfig(                                v2rayUrl,                                mainViewModel.subscriptionId,                                false                              )                            if (count > 0) {                                mainViewModel.reloadServerList()                                toast("配置获取成功")                                Log.d("MainActivity", "Config poll success, count: $count")                                highlightCountryFromUrl(v2rayUrl)                                enableUserInteraction()                            } else {                                Log.w("MainActivity", "Config poll failed - no configs imported")                                toast("配置导入失败")                                enableUserInteraction()                            }                        } else {                            Log.d("MainActivity", "Config polling - v2rayurl still empty, retrying in 3s")                            lifecycleScope.launch {                                delay(3000)                                pollUserInfo(uuid)                            }                        }                    } ?: run {                        Log.d("MainActivity", "Config polling - null response, retrying in 3s")                        lifecycleScope.launch {                            delay(3000)                            pollUserInfo(uuid)                        }                    }                }            } catch (e: Exception) {                Log.e("MainActivity", "Config polling error: $e")                lifecycleScope.launch {                    delay(3000)                    pollUserInfo(uuid)                }            }        }    }    override fun onKeyDown(keyCode: Int, event: KeyEvent): Boolean {        if (keyCode == KeyEvent.KEYCODE_BACK || keyCode == KeyEvent.KEYCODE_BUTTON_B) {            moveTaskToBack(false)            return true        }        return super.onKeyDown(keyCode, event)    }    private fun fetchAndImportConfig(uuid: String) {        disableUserInteraction()        clearAllConfigs()        lifecycleScope.launch {            try {                val result = withContext(Dispatchers.IO) {                    getUserInfoRequest(uuid)                }                withContext(Dispatchers.Main) {                    result?.let { v2rayUrl ->                        if (v2rayUrl.isNotEmpty()) {                            val (count, countSub) = AngConfigManager.importBatchConfig(                                v2rayUrl,                                mainViewModel.subscriptionId,                                false                              )                            if (count > 0) {                                mainViewModel.reloadServerList()                                toast("配置导入成功，共导入 $count 个服务器")                                Log.d("MainActivity", "Config imported successfully, count: $count")                                highlightCountryFromUrl(v2rayUrl)                                enableUserInteraction()                            } else {                                Log.w("MainActivity", "No configuration imported")                                toast("配置导入失败，请检查配置格式")                                enableUserInteraction()                            }                        } else {                            Log.w("MainActivity", "V2ray URL is empty, calling adduser and starting polling")                            addUser(uuid)                            lifecycleScope.launch {                                delay(10)                                pollUserInfo(uuid)                            }                        }                    } ?: run {                        Log.w("MainActivity", "No response, calling adduser and starting polling")                        addUser(uuid)                        lifecycleScope.launch {                            delay(10)                            pollUserInfo(uuid)                        }                    }                }            } catch (e: Exception) {                Log.e("MainActivity", "Error fetching config", e)                addUser(uuid)                lifecycleScope.launch {                    delay(10)                    pollUserInfo(uuid)                }            }        }    }    private fun getUserInfoRequest(uuid: String): String? {        var connection: HttpURLConnection? = null        try {            val url = URL("https:            connection = url.openConnection() as HttpURLConnection            connection.requestMethod = "POST"            connection.setRequestProperty("Content-Type", "application/json")            connection.setRequestProperty("Accept", "application/json")            connection.doOutput = true            connection.connectTimeout = 10000            connection.readTimeout = 15000            val jsonObject = JSONObject()            jsonObject.put("code", uuid)            val jsonInputString = jsonObject.toString()            connection.outputStream.use { os ->                val input = jsonInputString.toByteArray(Charsets.UTF_8)                os.write(input, 0, input.size)            }            val responseCode = connection.responseCode            if (responseCode == HttpURLConnection.HTTP_OK) {                val response = connection.inputStream.bufferedReader().use { it.readText() }                val jsonResponse = JSONObject(response)                return jsonResponse.optString("v2rayurl", "")            } else {                Log.e("MainActivity", "HTTP error: $responseCode")                return null            }        } catch (e: Exception) {            Log.e("MainActivity", "Request failed", e)            throw e        } finally {            connection?.disconnect()        }    }    private fun highlightCountryFromUrl(v2rayUrl: String) {        try {            val index = v2rayUrl.lastIndexOf("#")            if (index != -1 && index < v2rayUrl.length - 1) {                val countryCode = v2rayUrl.substring(index + 1)                Log.d("MainActivity", "Parsed country code from v2rayurl: $countryCode")                countrySelectorAdapter.setSelectedCountry(countryCode)                currentRegion = countryCode            } else {                Log.w("MainActivity", "No country code found in v2rayurl: $v2rayUrl")            }        } catch (e: Exception) {            Log.e("MainActivity", "Error parsing country code from v2rayurl", e)        }    }    private fun switchRegion(newZone: String) {        if (isSwitching || newZone == currentRegion) {            Log.d("MainActivity", "Switch ignored: isSwitching=$isSwitching, newZone=$newZone, currentRegion=$currentRegion")            return        }        Log.d("MainActivity", "Starting region switch to: $newZone")        isSwitching = true        targetRegion = newZone        maxProgress = 0          showProgressIndicator("正在切换区域...", 0)        disableUserInteraction()        wasVpnOn = (mainViewModel.isRunning.value == true)        Log.d("MainActivity", "VPN was on before switch: $wasVpnOn")        if (wasVpnOn) {            Log.d("MainActivity", "Stopping VPN before region switch")            binding.fab.performClick()            lifecycleScope.launch {                delay(1000)                  sendSwitchRequest(newZone)            }        } else {            sendSwitchRequest(newZone)        }    }    private fun sendSwitchRequest(newZone: String) {        lifecycleScope.launch(Dispatchers.IO) {            val maxRetries = 2            for (attempt in 1..maxRetries) {                try {                    Log.d("MainActivity", "Sending switch request for $newZone (attempt $attempt/$maxRetries)")                    val response = switchRegionRequest(newZone)                    when (response.code) {                        200 -> {                            Log.d("MainActivity", "Switch request successful (200)")                            withContext(Dispatchers.Main) {                                startPollingStatus()                            }                            return@launch                        }                        202 -> {                            Log.d("MainActivity", "Switch request accepted (202), starting polling")                            withContext(Dispatchers.Main) {                                startPollingStatus()                            }                            return@launch                        }                        504 -> {                            Log.d("MainActivity", "Gateway timeout (504), starting polling anyway")                            withContext(Dispatchers.Main) {                                startPollingStatus()                            }                            return@launch                        }                        else -> {                            if (attempt < maxRetries) {                                Log.w("MainActivity", "Switch failed with code ${response.code}, retrying...")                                delay(3000)                            } else {                                Log.e("MainActivity", "Switch failed with code ${response.code}")                                withContext(Dispatchers.Main) {                                    onSwitchFailed("切换失败 (HTTP ${response.code})")                                }                                return@launch                            }                        }                    }                } catch (e: Exception) {                    Log.e("MainActivity", "Switch request error (attempt $attempt)", e)                    if (attempt < maxRetries) {                        delay(3000)                    } else {                        withContext(Dispatchers.Main) {                            onSwitchFailed("网络请求失败: ${e.message}")                        }                        return@launch                    }                }            }        }    }    private fun switchRegionRequest(newZone: String): HttpResponse {        var connection: HttpURLConnection? = null        return try {            val url = URL("https:            connection = url.openConnection() as HttpURLConnection            connection.requestMethod = "POST"            connection.setRequestProperty("Content-Type", "application/json")            connection.setRequestProperty("Accept", "application/json")            connection.doOutput = true            connection.connectTimeout = 30000              connection.readTimeout = 30000            val jsonObject = JSONObject()            jsonObject.put("code", getUserUuid())              jsonObject.put("newZone", newZone)            val jsonInputString = jsonObject.toString()            connection.outputStream.use { os ->                val input = jsonInputString.toByteArray(Charsets.UTF_8)                os.write(input, 0, input.size)            }            val responseCode = connection.responseCode            val responseBody = if (responseCode == HttpURLConnection.HTTP_OK) {                connection.inputStream.bufferedReader().use { it.readText() }            } else {                connection.errorStream?.bufferedReader()?.use { it.readText() } ?: ""            }            HttpResponse(responseCode, responseBody)        } catch (e: Exception) {            Log.e("MainActivity", "Switch request network error", e)            throw e        } finally {            connection?.disconnect()        }    }    private data class HttpResponse(val code: Int, val body: String)    private fun getUserUuid(): String {        return userUuid ?: ""    }    private fun getUserInfoFullRequest(uuid: String): JSONObject? {        var connection: HttpURLConnection? = null        return try {            val url = URL("https:            connection = url.openConnection() as HttpURLConnection            connection.requestMethod = "POST"            connection.setRequestProperty("Content-Type", "application/json")            connection.setRequestProperty("Accept", "application/json")            connection.doOutput = true            connection.connectTimeout = 10000            connection.readTimeout = 15000            val jsonObject = JSONObject()            jsonObject.put("code", uuid)            val jsonInputString = jsonObject.toString()            connection.outputStream.use { os ->                val input = jsonInputString.toByteArray(Charsets.UTF_8)                os.write(input, 0, input.size)            }            val responseCode = connection.responseCode            if (responseCode == HttpURLConnection.HTTP_OK) {                val response = connection.inputStream.bufferedReader().use { it.readText() }                return JSONObject(response)            } else {                Log.e("MainActivity", "HTTP error: $responseCode")                return null            }        } catch (e: Exception) {            Log.e("MainActivity", "Request failed", e)            return null        } finally {            connection?.disconnect()        }    }    private fun disableUserInteraction() {        binding.fab.isEnabled = false        binding.countryRecyclerView.isEnabled = false        countrySelectorAdapter.isSwitching = true        binding.pbWaiting.isVisible = true        toast("正在切换区域...")        Log.d("MainActivity", "User interaction disabled")    }    private fun enableUserInteraction() {        binding.fab.isEnabled = true        binding.countryRecyclerView.isEnabled = true        countrySelectorAdapter.isSwitching = false        binding.pbWaiting.isVisible = false        Log.d("MainActivity", "User interaction enabled")    }    private fun startPollingStatus() {        pollAttempts = 0        Log.d("MainActivity", "Starting polling for region switch to $targetRegion")        pollSwitchStatus()    }    private fun pollSwitchStatus() {        lifecycleScope.launch(Dispatchers.IO) {            try {                val jsonResponse = getUserInfoFullRequest(getUserUuid())                withContext(Dispatchers.Main) {                    jsonResponse?.let { json ->                        val zone = json.optString("zone", "")                        val vmname = json.optString("vmname", "")                        val v2rayurl = json.optString("v2rayurl", "")                        Log.d("MainActivity", "Poll attempt $pollAttempts: zone=$zone, vmname=$vmname, v2rayurl_empty=${v2rayurl.isEmpty()}")                        if (zone == targetRegion && v2rayurl.isNotEmpty()) {                            Log.d("MainActivity", "Switch completed: zone matches target and v2rayurl available")                            onSwitchSuccess(v2rayurl)                            return@withContext                        }                        if (vmname.contains(targetRegion ?: "")) {                            Log.d("MainActivity", "VM name contains target region: $vmname")                            fetchVmProgress(vmname)                            if (v2rayurl.isNotEmpty()) {                                Log.d("MainActivity", "Switch completed: vmname matches and v2rayurl available")                                onSwitchSuccess(v2rayurl)                                return@withContext                            }                        }                        pollAttempts++                        if (pollAttempts % 2 == 0) {                             val estimatedProgress = minOf(10 + pollAttempts, 90)                            updateProgress("正在等待切换完成...", estimatedProgress)                        }                        if (pollAttempts < maxPollAttempts) {                            delay(5000)                              pollSwitchStatus()                        } else {                            Log.e("MainActivity", "Polling timeout after ${maxPollAttempts * 5} seconds")                            onSwitchFailed("切换超时，请检查网络连接")                        }                    } ?: run {                        pollAttempts++                        if (pollAttempts < maxPollAttempts) {                            delay(5000)                            pollSwitchStatus()                        } else {                            onSwitchFailed("切换超时，请检查网络连接")                        }                    }                }            } catch (e: Exception) {                Log.e("MainActivity", "Polling error", e)                withContext(Dispatchers.Main) {                    pollAttempts++                    if (pollAttempts < maxPollAttempts) {                        delay(5000)                        pollSwitchStatus()                    } else {                        onSwitchFailed("网络连接异常")                    }                }            }        }    }    private fun fetchVmProgress(vmname: String) {        lifecycleScope.launch(Dispatchers.IO) {            try {                val url = URL("https:                val connection = url.openConnection() as HttpURLConnection                connection.requestMethod = "POST"                connection.setRequestProperty("Content-Type", "application/json")                connection.doOutput = true                connection.connectTimeout = 10000                connection.readTimeout = 10000                val jsonObject = JSONObject()                jsonObject.put("vmname", vmname)                val jsonInputString = jsonObject.toString()                connection.outputStream.use { os ->                    val input = jsonInputString.toByteArray(Charsets.UTF_8)                    os.write(input, 0, input.size)                }                if (connection.responseCode == HttpURLConnection.HTTP_OK) {                    val response = connection.inputStream.bufferedReader().use { it.readText() }                    val jsonResponse = JSONObject(response)                    val progress = jsonResponse.optInt("progress", 0)                    Log.d("MainActivity", "VM creation progress: $progress%")                    withContext(Dispatchers.Main) {                        val displayProgress = maxOf(10, progress)                         updateProgress("正在创建服务器...", displayProgress)                    }                }                connection.disconnect()            } catch (e: Exception) {                Log.e("MainActivity", "Error fetching VM progress", e)            }        }    }    private fun onSwitchSuccess(v2rayurl: String) {        Log.d("MainActivity", "Region switch successful, importing new config")        clearAllConfigs()        val (count, _) = AngConfigManager.importBatchConfig(            v2rayurl,            mainViewModel.subscriptionId,            false          )        if (count > 0) {            mainViewModel.reloadServerList()            maxProgress = 100            updateProgress("切换成功", 100)            targetRegion?.let { region ->                countrySelectorAdapter.setSelectedCountry(region)                currentRegion = region                Log.d("MainActivity", "Updated highlight to region: $region")            }            lifecycleScope.launch {                delay(1000)                  hideProgressIndicator()                if (wasVpnOn) {                    Log.d("MainActivity", "Restoring VPN connection")                    delay(500)                      binding.fab.performClick()                  }            }            enableUserInteraction()            isSwitching = false            toast("区域切换成功")            Log.d("MainActivity", "Region switch completed successfully")        } else {            Log.e("MainActivity", "Failed to import new configuration")            onSwitchFailed("配置导入失败")        }    }    private fun showProgressIndicator(status: String, progress: Int) {        runOnUiThread {            binding.progressOverlay.visibility = android.view.View.VISIBLE            binding.progressStatus.text = status            binding.progressText.text = "${progress}%"            binding.circularProgress.setProgressCompat(progress, true)        }    }    private fun updateProgress(status: String, progress: Int) {        runOnUiThread {            if (progress > maxProgress) {                maxProgress = progress            }            binding.progressStatus.text = status            binding.progressText.text = "${maxProgress}%"            binding.circularProgress.setProgressCompat(maxProgress, true)        }    }    private fun hideProgressIndicator() {        runOnUiThread {            binding.progressOverlay.visibility = android.view.View.GONE        }    }    private fun onSwitchFailed(errorMsg: String) {        Log.e("MainActivity", "Region switch failed: $errorMsg")        hideProgressIndicator()        currentRegion?.let { region ->            countrySelectorAdapter.setSelectedCountry(region)        }        enableUserInteraction()        isSwitching = false        toast("切换失败: $errorMsg")    }}